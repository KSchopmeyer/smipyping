# (C) Copyright 2017 Inova Development Inc.
# All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Implementation of the exlorer cmd group.
"""
from __future__ import print_function, absolute_import

import click
from smipyping._explore import Explorer

from .smicli import cli, CMD_OPTS_TXT
from ._click_common import fold_cell, print_table


@cli.group('explorer', options_metavar=CMD_OPTS_TXT)
def explorer_group():
    """
    Command group to explore providers.

    This group of commands provides the tools for general explore of all
    providers defined in the database.

    The explore queries the providers and generates information on their
    state and status including if active, namespaces, profiles, etc.
    It also normally generates a log of all activity.

    This information is generated by accessing the provider itself.
    """
    pass


@explorer_group.command('all', options_metavar=CMD_OPTS_TXT)
@click.option('--ping/--no-ping', default=True,
              help='Ping the the provider as initial step in test. '
                   'Default: ping')
@click.option('--thread/--no-thread', default=True,
              help='Run test multithreaded.  Much faster. '
                   'Default: thread')
@click.option('-r', '--report', type=click.Choice(['full', 'brief']),
              default='full',
              help='Generate full or brief (fewer columns) report')
@click.pass_obj
def explore_all(context, **options):
    """
    Command group to explore servers


    Execute the general explore operation on  some or all the providers in the
    database.

    This command explores the general characteristics of the server including:

    Namespaces
    Interop Namespace
    Registered Profiles
    General Server information

    I can operate either in a parallel mode (multi-threaded) or single
    thread (if for some reason there is an issue with the multithreading)

    It generates a report to the the defined output as a table with the
    formatting defined by the format option. Default is thread the requests
    speeding up the explore significantly.

    Note: There is an option to ping the server before executing the
    explore simply to speed up the process for servers that are completely
    not available. Default is to ping as the first step.

    """
    context.execute_cmd(lambda: cmd_explore_all(context, **options))


@explorer_group.command('ids', options_metavar=CMD_OPTS_TXT)
@click.argument('IDs', type=int, metavar='TargetIDs', required=True, nargs=-1)
@click.option('--ping/--no-ping', default=True,
              help='Ping the the provider as initial step in test. '
                   'Default: ping')
@click.option('--thread/--no-thread', default=True,
              help='Run test multithreaded.  Much faster. '
                   'Default: thread')
@click.option('-r', '--report', type=click.Choice(['full', 'brief']),
              default='full',
              help='Generate full or brief (fewer columns) report')
@click.pass_obj
def explore_id(context, ids, **options):
    """
    Execute the general explorer on the providers defined by id.  Multiple
    ids may be supplied (ex. id 5 6 7)

    """
    context.execute_cmd(lambda: cmd_explore_ids(context, ids, **options))


######################################################################
#
#  Action functions
#
######################################################################

def cmd_explore_all(context, **options):
    """Explore all of the providers defined in the current database and
    report results.
    """

    # TODO configure logging
    # TODO fix the log_level stuff
    explorer = Explorer('smicli', context.targets_tbl,
                        logfile=context.log_file,
                        log_level=None,
                        verbose=context.verbose,
                        ping=options['ping'],
                        threaded=options['thread'],
                        output_format=context.output_format)

    # TODO: ks I believe that the following is irrelevent. It maps between
    # hosts and targets and so does not gain much
    hosts = context.targets_tbl.get_hostid_list()
    targets = []
    for host in hosts:
        if context.verbose:
            print('targets extend host %s, rtns %s' %
                  (host, context.targets_tbl.get_target_for_host(host)))

        targets.extend(context.targets_tbl.get_target_for_host(host))

    targets = set(targets)

    servers = explorer.explore_servers(targets)

    # print results
    # TODO make this part of normal print services
    context.spinner.stop()
    report_server_info(servers, context.targets_tbl, context.output_format,
                       report=options['report'])


def cmd_explore_ids(context, ids, **options):
    """
    Explore the wbem server defined by the Id provided
    """
    # TODO: ks redo this code to use the record once it is acquired.
    for id_ in ids:
        try:
            targ_rec = context.targets_tbl.get_target(id_)  # noqa: F841
        except Exception as ex:
            raise click.ClickException('Invalid TargetID=%s. Not in database. '
                                       '%s: %s' % (id,
                                                   ex.__class__.__name__, ex))

    explorer = Explorer('smicli', context.targets_tbl,
                        verbose=context.verbose,
                        ping=options['ping'],
                        threaded=options['thread'],
                        logfile=context.log_file,
                        log_level=context.log_level,
                        output_format=context.output_format)

    servers = explorer.explore_servers(ids)
    context.spinner.stop()
    report_server_info(servers, context.targets_tbl,
                       context.output_format,
                       report=options['report'])

##############################################################
#
#   Table generation functions
#
############################################################


def report_server_info(servers, targets_tbl, output_format,
                       table_format='table',
                       columns=None, report='full'):
    """ Display a table of info from the server scan
    """

    rows = []
    if report == 'full':
        headers = ['Id', 'Url', 'Company', 'Product', 'Vers',
                   'SMI Profiles', 'Interop_ns', 'Status', 'time']
    else:
        headers = ['Id', 'Url', 'Company', 'Product',
                   'Status', 'time']
    servers.sort(key=lambda tup: int(tup.target_id))
    for server_tuple in servers:
        url = server_tuple.url
        server = server_tuple.server
        status = server_tuple.status
        target_id = server_tuple.target_id
        target = targets_tbl.get_target(target_id)
        version = ''
        interop_ns = ''
        smi_profiles = ''
        if server is not None and status == 'OK':
            version = server.version
            interop_ns = server.interop_ns
            smi_profile_list = smi_versions(server_tuple.server)
            if smi_profile_list is not None:
                cell_str = ", ". join(sorted(smi_profile_list))
                smi_profiles = (fold_cell(cell_str, 14))
        disp_time = None
        if server_tuple.time <= 60:
            disp_time = "%.2fs" % (round(server_tuple.time, 1))
        else:
            disp_time = "%.2fm" % (server_tuple.time / 60)
        row = []
        if 'Id' in headers:
            row.append(target_id)
        if 'Url' in headers:
            row.append(url)
        if 'Company' in headers:
            row.append(fold_cell(target['CompanyName'], 11),)
        if 'Product' in headers:
            row.append(fold_cell(target['Product'], 8),)
        if 'Vers' in headers:
            row.append(version)
        if 'SMI Profiles' in headers:
            row.append(smi_profiles)
        if 'Interop_ns' in headers:
            row.append(interop_ns)
        if 'Status' in headers:
            row.append(server_tuple.status)
        if 'time' in headers:
            row.append(disp_time)

        rows.append(row)

    print_table(rows, headers=headers,
                title='Server Explorer Report:',
                table_format=output_format)


def smi_versions(server):
    """
    Get the smi version used by this server from the SNIA profile
    information on the server.
    If it cannot be found in the registered profiles an exception is
    generated (TypeError)
    Returns empty if cannot be found.
    TODO what do we do about the exception te that can happen from
    get_selected_profiles
    """
    try:
        snia_server_profiles = server.get_selected_profiles(
            registered_org='SNIA', registered_name='SMI-S')
    except TypeError as te:
        click.echo('ERROR: Invalid profile definition caused exception for %s. '
                   'exception %s' % (server.conn.url, te))
        return []

    versions = [inst['RegisteredVersion'] for inst in snia_server_profiles]

    return versions


def print_smi_profile_info(servers, user_data, table_format):
    """
    Generates a table of smi profile information listing the smi profiles

    Parameters:

      servers: list of ServerInfoTuple entries
    """

    table_data = []
    table_hdr = [' Id', 'Url', 'Company', 'Product', 'SMI Profiles']
    table_data.append(table_hdr)
    for server_tuple in servers:
        if server_tuple.status == 'OK':
            target_id = server_tuple.target_id
            entry = user_data.get_target(target_id)
            try:
                versions = smi_versions(server_tuple.server)
            except Exception as ex:
                # TODO make this an error log entry.
                print('Exception %s in smi_version %s' % (ex,
                                                          server_tuple))
                versions = []

            line = [entry['TargetID'],
                    server_tuple.url,
                    entry['CompanyName'],
                    entry['Product']]
            if versions is not None:
                cell_str = ", ". join(sorted(versions))
                line.append(fold_cell(cell_str, 14))
            table_data.append(line)

    print_table(table_data, headers=table_hdr,
                title='Display SMI Profile Information',
                table_format=table_format)
